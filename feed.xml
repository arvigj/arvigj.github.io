<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://arvigj.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://arvigj.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-07-10T17:07:20+00:00</updated><id>https://arvigj.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Cascaded Shape Optimization using PolyFEM</title><link href="https://arvigj.github.io/blog/2024/pneumatic-actuator-optimization/" rel="alternate" type="text/html" title="Cascaded Shape Optimization using PolyFEM"/><published>2024-07-07T15:12:00+00:00</published><updated>2024-07-07T15:12:00+00:00</updated><id>https://arvigj.github.io/blog/2024/pneumatic-actuator-optimization</id><content type="html" xml:base="https://arvigj.github.io/blog/2024/pneumatic-actuator-optimization/"><![CDATA[<h1 id="cascaded-shape-optimization-using-polyfem-draft-in-progress">Cascaded Shape Optimization using PolyFEM (Draft In Progress)</h1> <p><strong><em>A tutorial for setting up shape optimization of pneumatic robots, with <a href="https://github.com/arvigj/pneumatic-actuator-design">full examples</a></em></strong></p> <p>In this tutorial, I’ll be outlining how to setup the shape optimization from the paper <a href="https://cims.nyu.edu/gcl/papers/2024-pneumatic.pdf">‘Soft Pneumatic Actuator Design using Differentiable Simulation’</a>. I’ll be assuming familiarity with the paper, including the finite element method and optimization in general. For a background into these topics, there will be a blog post in the future. We will be using the differentiable finite element simulator <a href="https://github.com/polyfem/polyfem">PolyFEM</a>, which has support for high order basis, a multitude of material models, physical energies and state-of-the-art contact/friction (<a href="https://github.com/ipc-sim/ipc-toolkit">IPC</a>). The cascading algorithm is implemented in Python and can be found <a href="https://github.com/arvigj/pneumatic-actuator-design">with the configuration files</a>. <a href="https://www.mmgtools.org">MMG</a> is also required for interior remeshing.</p> <h2 id="simulation-setup">Simulation Setup</h2> <p>Readers should take a look at the <a href="https://polyfem.github.io/tutorials/getting_started/">PolyFEM docs</a> for complete tutorials on setting up a simulation, with a full breakdown of features, options for contact, solvers, output, etc. For this section, we will focus on some requirements for the simulation: the mesh, surface selections and boundary conditions.</p> <h3 id="mesh">Mesh</h3> <p>A finite element simulation requires a volumetric mesh. This can be created from a surface mesh using <a href="https://github.com/wildmeshing/fTetWild">fTetWild</a>, which exposes a lot of control over mesh quality. Alternatively, if designed in CAD, volumetric meshes are directly available.</p> <h3 id="surface-selections">Surface selections</h3> <p>We provide a utility to select surface based on bounding volumes. Given a volumetric mesh and surface meshes bounding surfaces of interest, our utility in <code class="language-plaintext highlighter-rouge">setup_scene_3d/setup_3d.cpp</code> computes the surface selections and assigns distinct ids for use in the simulation. The output is a <code class="language-plaintext highlighter-rouge">.txt</code> file mapping surface triangles to boundary ids.</p> <h3 id="boundary-conditions">Boundary conditions</h3> <p>Once you’ve marked the surface selections and specified them in the json, you can use them as boundary conditions.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"boundary_conditions": {
    "dirichlet_boundary": [{
        "id": 0,
        "value": [0, 0, 0]
    }],
    "pressure_boundary": [{
        "id": 1,
        "value": "min(-4000 * t, -4000)"
    }]
}
</code></pre></div></div> <p>Dirichlet boundary conditions require a specification of a displacement vector \([x, y, z]\) whereas pressure boundary conditions only require a pressure scalar that is applied normal to the surface \(p \, \hat{n}\). PolyFEM also accepts functions of \(x, y, z, t\) as boundary condition values, allowing pressure to be varied over time as the linear ramp <code class="language-plaintext highlighter-rouge">min(-4000 * t, -4000)</code>. There are other functions available and boundary conditions can also be specified per timestep (see worm example).</p> <p><strong>Important Note About Simulation:</strong> For mathematical reasons, the boundary loop of a surface with applied pressure must be either held constant with Dirichlet b.c. or the whole surface must be closed.</p> <h2 id="optimization-setup">Optimization Setup</h2> <p>Once the simulation is setup, setting up the optimization requires specifying:</p> <ol> <li>The parameters being optimized and their starting values.</li> <li>The parametrizations mapping the parameters to simulation variables, i.e. quantities that the simulation directly uses. In the case of simply optimizing vertex positions, the parametrization is the identity map.</li> <li>The optimization objectives, which can be a list of summed functionals. While there are many of them and new ones are constantly added in PolyFEM, the ones we will detail are: <ul> <li><code class="language-plaintext highlighter-rouge">mesh-target</code> – <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
  "type": "mesh-target",
  "state": 0,
  "surface_selection": [
      4
  ],
  "mesh_path": "cylinder_smaller_target_v2.obj",
  "delta": 0.001
 }
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">log_contact_force_norm</code></li> <li><code class="language-plaintext highlighter-rouge">layer_thickness</code></li> <li><code class="language-plaintext highlighter-rouge">transient_integral</code> – This objective is needed to wrap all of our other objectives, which are effectively static objectives (for a given displacement at time t). Through this objective, one can specify a timestep to evaluate the static objectives or evaluate them over the course of the simulation. The syntax looks as follows, with the static objective being surface matching to a mesh evaluated at time steps 53 and 54: ``` { “type”: “transient_integral”, “weight”: -1e4, “integral_type”: “steps”, “steps”: [ 53, 54 ], “state”: 0, “static_objective”: { “type”: “mesh-target”, … } }</li> </ul> <p>```</p> <ul> <li><code class="language-plaintext highlighter-rouge">collision_barrier</code> – Since we’re using a quadratic barrier in our <code class="language-plaintext highlighter-rouge">layer_thickness</code> objective, we might want to add a “hard” constraint to prevent surfaces going through one another. If we keep the support of this objective small, we can ensure that the optimization does not reach an invalid state while preventing this objective from really contributing to the energy. This objective is not crucial to the optimization and can be left out.</li> </ul> </li> </ol> <h2 id="cascaded-optimization">Cascaded Optimization</h2> <p>At this point, you can add the new optimization info to the <code class="language-plaintext highlighter-rouge">OPTIMIZATIONS</code> dict in <code class="language-plaintext highlighter-rouge">multigrid_optimization.py</code>. Using a key <code class="language-plaintext highlighter-rouge">&lt;example_key&gt;</code>, the necessary fields are:</p> <p><code class="language-plaintext highlighter-rouge">base_path</code>: The base directory for the optimization files, where the results will be stored.</p> <p><code class="language-plaintext highlighter-rouge">state_path</code>: The filename of the simulation json.</p> <p><code class="language-plaintext highlighter-rouge">run_path</code>: The filename of the optimization json.</p> <p><code class="language-plaintext highlighter-rouge">num_control_points</code>: For each of the surfaces being optimized, this specified the degrees of freedom for each optimization step. It is zero indexed starting with the first parameter in the optimization json.</p> <p><code class="language-plaintext highlighter-rouge">num_iters</code>: Specifies the number of iterations for each optimization step.</p> <p><code class="language-plaintext highlighter-rouge">opt_mesh_idx</code>: Specifies the index of the mesh being indexed in the simulation json, in the <code class="language-plaintext highlighter-rouge">geometry</code> section.</p> <p><code class="language-plaintext highlighter-rouge">aux_files</code>: Specifies the auxiliary files that are copied to the run directory, such as mesh targets, etc.</p> <p><code class="language-plaintext highlighter-rouge">threads</code>: Number of threads that the forward simulation is allowed.</p> <p>The optimization can then be executed by the following command</p> <p><code class="language-plaintext highlighter-rouge">python multigrid_optimization.py &lt;example_key&gt; &lt;run_path&gt; &lt;polyfem_build_dir&gt; &lt;mmg_build_dir&gt; &lt;absolute_path&gt; L-BFGS</code></p>]]></content><author><name></name></author><category term="optimization"/><category term="formatting"/><category term="math"/><summary type="html"><![CDATA[A tutorial for setting up shape optimization of pneumatic robots]]></summary></entry></feed>